"""POL-005: System-Level Exploit Protection Assessment.

Queries Get-ProcessMitigation -System to check system-wide exploit
protection settings including DEP, ASLR, CFG, SEHOP, and Heap
termination. These mitigations provide defense-in-depth against
memory corruption exploits.
"""

from __future__ import annotations

from vitia_invenire.checks.base import BaseCheck
from vitia_invenire.collectors.powershell import run_ps
from vitia_invenire.models import Category, Finding, Severity

# Mitigation value interpretation:
# "ON" = explicitly enabled
# "OFF" = explicitly disabled
# "NOTSET" = not configured, OS default applies (usually enabled)
# True/False may also appear depending on PowerShell version

# DEP policy modes
_DEP_POLICY_NAMES: dict[str, str] = {
    "AlwaysOn": "Always On (all processes)",
    "AlwaysOff": "Always Off (disabled for all processes)",
    "OptIn": "Opt In (enabled for Windows system processes and opted-in apps)",
    "OptOut": "Opt Out (enabled for all processes except opted-out apps)",
}


def _is_off(value: object) -> bool:
    """Return True if the mitigation value represents an explicitly disabled state."""
    if value is None:
        return False
    val_str = str(value).strip().upper()
    return val_str in ("OFF", "FALSE", "0", "ALWAYSOFF")


def _is_on(value: object) -> bool:
    """Return True if the mitigation value represents an explicitly enabled state."""
    if value is None:
        return False
    val_str = str(value).strip().upper()
    return val_str in ("ON", "TRUE", "1", "ALWAYSON", "OPTOUT")


def _is_notset(value: object) -> bool:
    """Return True if the mitigation value is not explicitly configured."""
    if value is None:
        return True
    val_str = str(value).strip().upper()
    return val_str in ("NOTSET", "")


class ExploitProtectionCheck(BaseCheck):
    """Assess system-level exploit protection mitigations."""

    CHECK_ID = "POL-005"
    NAME = "Exploit Protection"
    DESCRIPTION = (
        "Queries system-level exploit protection settings including DEP, "
        "ASLR (mandatory and bottom-up), Control Flow Guard, SEHOP, and "
        "Heap termination on error. These mitigations harden the system "
        "against memory corruption and code execution exploits."
    )
    CATEGORY = Category.POLICY
    REQUIRES_ADMIN = False

    def run(self) -> list[Finding]:
        findings: list[Finding] = []

        result = run_ps(
            "Get-ProcessMitigation -System -ErrorAction SilentlyContinue",
            timeout=15,
            as_json=True,
        )

        if not result.success or result.json_output is None:
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Exploit protection query failed",
                description=(
                    "Could not query system-level exploit protection settings "
                    "via Get-ProcessMitigation. This cmdlet may not be available "
                    "on this version of Windows. "
                    f"Error: {result.error or 'no data returned'}"
                ),
                severity=Severity.MEDIUM,
                category=self.CATEGORY,
                affected_item="Exploit Protection",
                evidence=result.output[:500] if result.output else "No output",
                recommendation=(
                    "Get-ProcessMitigation requires Windows 10 1709 or later. "
                    "Verify the Windows version and try running as Administrator."
                ),
            ))
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Exploit protection assessment incomplete",
                description="Could not retrieve system mitigation settings.",
                severity=Severity.INFO,
                category=self.CATEGORY,
                affected_item="Exploit Protection",
                evidence="Get-ProcessMitigation query failed",
                recommendation="Retry on a supported Windows version.",
            ))
            return findings

        mitigations = result.json_output
        if isinstance(mitigations, list) and len(mitigations) > 0:
            mitigations = mitigations[0]

        evidence_lines: list[str] = []

        # -- DEP --
        dep_data = mitigations.get("DEP", {})
        if dep_data is None:
            dep_data = {}
        if isinstance(dep_data, dict):
            dep_enable = dep_data.get("Enable")
            dep_atl_thunk = dep_data.get("EmulateAtlThunks")
        else:
            dep_enable = dep_data
            dep_atl_thunk = None

        evidence_lines.append(f"DEP.Enable: {dep_enable}")
        if dep_atl_thunk is not None:
            evidence_lines.append(f"DEP.EmulateAtlThunks: {dep_atl_thunk}")

        self._check_dep(findings, dep_enable, "\n".join(evidence_lines))

        # -- ASLR --
        aslr_data = mitigations.get("ASLR", {})
        if aslr_data is None:
            aslr_data = {}
        if isinstance(aslr_data, dict):
            aslr_force_relocate = aslr_data.get("ForceRelocateImages")
            aslr_bottom_up = aslr_data.get("BottomUp")
            aslr_high_entropy = aslr_data.get("HighEntropy")
        else:
            aslr_force_relocate = None
            aslr_bottom_up = None
            aslr_high_entropy = None

        evidence_lines.append(f"ASLR.ForceRelocateImages: {aslr_force_relocate}")
        evidence_lines.append(f"ASLR.BottomUp: {aslr_bottom_up}")
        if aslr_high_entropy is not None:
            evidence_lines.append(f"ASLR.HighEntropy: {aslr_high_entropy}")

        self._check_aslr(
            findings, aslr_force_relocate, aslr_bottom_up,
            aslr_high_entropy, "\n".join(evidence_lines),
        )

        # -- CFG (Control Flow Guard) --
        cfg_data = mitigations.get("CFG", {})
        if cfg_data is None:
            cfg_data = {}
        if isinstance(cfg_data, dict):
            cfg_enable = cfg_data.get("Enable")
            cfg_suppress_exports = cfg_data.get("SuppressExports")
            cfg_strict_mode = cfg_data.get("StrictCFG")
        else:
            cfg_enable = cfg_data
            cfg_suppress_exports = None
            cfg_strict_mode = None

        evidence_lines.append(f"CFG.Enable: {cfg_enable}")
        if cfg_suppress_exports is not None:
            evidence_lines.append(f"CFG.SuppressExports: {cfg_suppress_exports}")
        if cfg_strict_mode is not None:
            evidence_lines.append(f"CFG.StrictCFG: {cfg_strict_mode}")

        self._check_cfg(findings, cfg_enable, "\n".join(evidence_lines))

        # -- SEHOP (Structured Exception Handler Overwrite Protection) --
        sehop_data = mitigations.get("SEHOP", {})
        if sehop_data is None:
            sehop_data = {}
        if isinstance(sehop_data, dict):
            sehop_enable = sehop_data.get("Enable")
            sehop_telemetry = sehop_data.get("TelemetryOnly")
        else:
            sehop_enable = sehop_data
            sehop_telemetry = None

        evidence_lines.append(f"SEHOP.Enable: {sehop_enable}")
        if sehop_telemetry is not None:
            evidence_lines.append(f"SEHOP.TelemetryOnly: {sehop_telemetry}")

        self._check_sehop(findings, sehop_enable, "\n".join(evidence_lines))

        # -- Heap --
        heap_data = mitigations.get("Heap", {})
        if heap_data is None:
            heap_data = {}
        if isinstance(heap_data, dict):
            heap_terminate = heap_data.get("TerminateOnError")
        else:
            heap_terminate = heap_data

        evidence_lines.append(f"Heap.TerminateOnError: {heap_terminate}")

        self._check_heap(findings, heap_terminate, "\n".join(evidence_lines))

        # -- System Image Randomization --
        image_load = mitigations.get("ImageLoad", {})
        if isinstance(image_load, dict):
            block_remote = image_load.get("BlockRemoteImageLoads")
            block_low_label = image_load.get("BlockLowLabelImageLoads")
            if block_remote is not None:
                evidence_lines.append(f"ImageLoad.BlockRemoteImageLoads: {block_remote}")
            if block_low_label is not None:
                evidence_lines.append(f"ImageLoad.BlockLowLabelImageLoads: {block_low_label}")

        evidence_text = "\n".join(evidence_lines)

        # Summary finding
        findings.append(Finding(
            check_id=self.CHECK_ID,
            title="Exploit protection assessment complete",
            description=(
                "Assessed system-level exploit protection mitigations "
                "including DEP, ASLR, CFG, SEHOP, and Heap termination."
            ),
            severity=Severity.INFO,
            category=self.CATEGORY,
            affected_item="Exploit Protection",
            evidence=evidence_text,
            recommendation=(
                "Review exploit protection settings against organizational "
                "hardening standards. Enable all available mitigations unless "
                "specific application compatibility issues require exceptions."
            ),
            references=[
                "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/exploit-protection",
                "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/enable-exploit-protection",
            ],
        ))

        return findings

    def _check_dep(
        self,
        findings: list[Finding],
        dep_enable: object,
        evidence: str,
    ) -> None:
        """Evaluate DEP (Data Execution Prevention) configuration."""
        if _is_off(dep_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="DEP is disabled",
                description=(
                    "Data Execution Prevention (DEP) is explicitly disabled "
                    "at the system level. DEP prevents code from executing "
                    "in memory regions marked as non-executable, which is a "
                    "fundamental defense against buffer overflow and code "
                    "injection exploits. Disabling DEP leaves the system "
                    "highly vulnerable to memory corruption attacks."
                ),
                severity=Severity.HIGH,
                category=self.CATEGORY,
                affected_item="DEP",
                evidence=evidence,
                recommendation=(
                    "Enable DEP in OptOut mode to protect all processes: "
                    "Set-ProcessMitigation -System -Enable DEP. "
                    "Also verify via bcdedit that nx is set to OptOut or AlwaysOn."
                ),
                references=[
                    "https://learn.microsoft.com/en-us/windows/win32/memory/data-execution-prevention",
                    "https://attack.mitre.org/techniques/T1055/",
                ],
            ))
        elif _is_on(dep_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="DEP is enabled",
                description="Data Execution Prevention is explicitly enabled at the system level.",
                severity=Severity.INFO,
                category=self.CATEGORY,
                affected_item="DEP",
                evidence=evidence,
                recommendation="No action needed. DEP is active.",
            ))
        # NOTSET = OS default, typically enabled; no finding needed beyond summary

    def _check_aslr(
        self,
        findings: list[Finding],
        force_relocate: object,
        bottom_up: object,
        high_entropy: object,
        evidence: str,
    ) -> None:
        """Evaluate ASLR settings."""
        # Mandatory ASLR (ForceRelocateImages)
        if _is_off(force_relocate):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Mandatory ASLR (ForceRelocateImages) is disabled",
                description=(
                    "Mandatory ASLR is explicitly disabled. This setting forces "
                    "relocation of images not compiled with /DYNAMICBASE. Without "
                    "it, legacy executables without ASLR support load at "
                    "predictable addresses, making them easier targets for "
                    "return-oriented programming (ROP) attacks."
                ),
                severity=Severity.MEDIUM,
                category=self.CATEGORY,
                affected_item="ASLR ForceRelocateImages",
                evidence=evidence,
                recommendation=(
                    "Enable mandatory ASLR: "
                    "Set-ProcessMitigation -System -Enable ForceRelocateImages. "
                    "Test application compatibility first as some legacy software "
                    "may not function with forced relocation."
                ),
                references=[
                    "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/exploit-protection-reference",
                ],
            ))

        # Bottom-up ASLR
        if _is_off(bottom_up):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Bottom-Up ASLR is disabled",
                description=(
                    "Bottom-Up ASLR is explicitly disabled. This randomizes "
                    "the base address of bottom-up allocations (stack, heap). "
                    "Without it, these memory regions are more predictable, "
                    "aiding exploitation."
                ),
                severity=Severity.MEDIUM,
                category=self.CATEGORY,
                affected_item="ASLR BottomUp",
                evidence=evidence,
                recommendation=(
                    "Enable Bottom-Up ASLR: "
                    "Set-ProcessMitigation -System -Enable BottomUpASLR"
                ),
                references=[
                    "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/exploit-protection-reference",
                ],
            ))

        # High Entropy ASLR
        if _is_off(high_entropy):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="High Entropy ASLR is disabled",
                description=(
                    "High Entropy ASLR is explicitly disabled. On 64-bit "
                    "systems, this increases the variance of ASLR randomization "
                    "from 8 bits to up to 24 bits of entropy, making address "
                    "prediction significantly harder."
                ),
                severity=Severity.LOW,
                category=self.CATEGORY,
                affected_item="ASLR HighEntropy",
                evidence=evidence,
                recommendation=(
                    "Enable High Entropy ASLR: "
                    "Set-ProcessMitigation -System -Enable HighEntropy"
                ),
            ))

    def _check_cfg(
        self,
        findings: list[Finding],
        cfg_enable: object,
        evidence: str,
    ) -> None:
        """Evaluate Control Flow Guard (CFG) configuration."""
        if _is_off(cfg_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Control Flow Guard (CFG) is disabled",
                description=(
                    "Control Flow Guard is explicitly disabled at the system "
                    "level. CFG validates indirect call targets at runtime to "
                    "prevent control-flow hijacking attacks such as vtable "
                    "overwrites and function pointer corruption. Disabling CFG "
                    "removes this protection."
                ),
                severity=Severity.MEDIUM,
                category=self.CATEGORY,
                affected_item="CFG",
                evidence=evidence,
                recommendation=(
                    "Enable CFG: "
                    "Set-ProcessMitigation -System -Enable CFG. "
                    "Note that CFG requires binaries compiled with /guard:cf "
                    "to be fully effective."
                ),
                references=[
                    "https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard",
                    "https://attack.mitre.org/techniques/T1055/",
                ],
            ))
        elif _is_on(cfg_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Control Flow Guard is enabled",
                description=(
                    "Control Flow Guard is explicitly enabled at the system level."
                ),
                severity=Severity.INFO,
                category=self.CATEGORY,
                affected_item="CFG",
                evidence=evidence,
                recommendation="No action needed. CFG is active.",
            ))

    def _check_sehop(
        self,
        findings: list[Finding],
        sehop_enable: object,
        evidence: str,
    ) -> None:
        """Evaluate SEHOP configuration."""
        if _is_off(sehop_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="SEHOP is disabled",
                description=(
                    "Structured Exception Handler Overwrite Protection (SEHOP) "
                    "is explicitly disabled. SEHOP prevents exploitation of "
                    "SEH (Structured Exception Handler) chain overwrites, a "
                    "common technique used to gain code execution in 32-bit "
                    "Windows applications."
                ),
                severity=Severity.MEDIUM,
                category=self.CATEGORY,
                affected_item="SEHOP",
                evidence=evidence,
                recommendation=(
                    "Enable SEHOP: "
                    "Set-ProcessMitigation -System -Enable SEHOP"
                ),
                references=[
                    "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/exploit-protection-reference",
                    "https://attack.mitre.org/techniques/T1203/",
                ],
            ))
        elif _is_on(sehop_enable):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="SEHOP is enabled",
                description=(
                    "Structured Exception Handler Overwrite Protection is "
                    "explicitly enabled."
                ),
                severity=Severity.INFO,
                category=self.CATEGORY,
                affected_item="SEHOP",
                evidence=evidence,
                recommendation="No action needed. SEHOP is active.",
            ))

    def _check_heap(
        self,
        findings: list[Finding],
        heap_terminate: object,
        evidence: str,
    ) -> None:
        """Evaluate Heap termination on error setting."""
        if _is_off(heap_terminate):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Heap termination on error is disabled",
                description=(
                    "Heap TerminateOnError is explicitly disabled. When enabled, "
                    "this causes a process to terminate immediately when a heap "
                    "corruption is detected rather than continuing with corrupted "
                    "state. Disabling it allows exploitation of heap corruption "
                    "vulnerabilities to proceed."
                ),
                severity=Severity.LOW,
                category=self.CATEGORY,
                affected_item="Heap TerminateOnError",
                evidence=evidence,
                recommendation=(
                    "Enable Heap TerminateOnError: "
                    "Set-ProcessMitigation -System -Enable TerminateOnHeapError"
                ),
                references=[
                    "https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/exploit-protection-reference",
                ],
            ))
        elif _is_on(heap_terminate):
            findings.append(Finding(
                check_id=self.CHECK_ID,
                title="Heap termination on error is enabled",
                description=(
                    "Heap TerminateOnError is explicitly enabled. Processes "
                    "will terminate immediately on heap corruption detection."
                ),
                severity=Severity.INFO,
                category=self.CATEGORY,
                affected_item="Heap TerminateOnError",
                evidence=evidence,
                recommendation="No action needed. Heap termination is active.",
            ))
